<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on David Wilde</title>
        <link>https://david.wilde-ventures.com/posts/</link>
        <description>Recent content in Posts on David Wilde</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 22 Mar 2023 09:31:06 +0100</lastBuildDate>
        <atom:link href="https://david.wilde-ventures.com/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>My Issue With LLM in Programming</title>
            <link>https://david.wilde-ventures.com/posts/my-issue-with-llm-in-programming/</link>
            <pubDate>Wed, 22 Mar 2023 09:31:06 +0100</pubDate>
            
            <guid>https://david.wilde-ventures.com/posts/my-issue-with-llm-in-programming/</guid>
            <description>There are organizations (example, nothing in particular about this Org, I stumbled over their blog post recently, which inspired the thoughts below) trying to build LLM-based systems that can program. In the example posted above they describe the difficulties with LLM and accessing real-word applications like databases.
The main issue that exists is hallucination. LLMs can write SQL, but they are often prone to making up tables, making up fields, and generally just writing SQL that if executed against your database would not actually be valid.</description>
            <content type="html"><![CDATA[<p>There are organizations (<a href="https://blog.langchain.dev/llms-and-sql/">example</a>,
nothing in particular about this Org, I stumbled over their blog post recently,
which inspired the thoughts below) trying to build LLM-based systems that can
program. In the example posted above they describe the difficulties with LLM
and accessing real-word applications like databases.</p>
<blockquote>
<p>The main issue that exists is hallucination. LLMs can write SQL, but they are
often prone to making up tables, making up fields, and generally just writing
SQL that if executed against your database would not actually be valid. So
one of the big challenges we face is how to ground the LLM in reality so that
it produces valid SQL. The main idea to fix this (we will go into more detail
below) is to provide the LLM with knowledge about what actually exists in the
database and tell it to write a SQL query consistent with that. However, this
runs into a second issue - the context window length. LLMs have some context
window which limits the amount of text they can operate over. This is
relevant because SQL databases often contain a lot of information. So if we
were to naively pass in all the data to ground the LLM in reality, we would
likely run into this issue. A third issue is a more basic one: sometimes the
LLM just messes up. The SQL it writes may be incorrect for whatever reason,
or it could be correct but just return an unexpected result. What do we do
then? Do we give up?</p>
</blockquote>
<p><a href="https://blog.langchain.dev/llms-and-sql/">Source</a></p>
<p>Without being able to prove it, I think that we cannot simply let LLMs write
the entire script. Programming languages (counting SQL as one in this case) are
structured, filled with rules and require precision. LLMs cannot provide that
100% of the time.</p>
<p>There is the argument that humans can’t do it either, and to this I’d respond
that first, a human can self-check if the code they are writing is working and
second, someone else needs to prove-read and try out that code. Or, we want to
live dangerously and push straight to production without tests and reviews.</p>
<p>The next argument pro-LLM use is that it should augment the human. Yes, I
agree, but nothing I’ve seen so far comes close to a good integration. What, in
my opinion, would be helpful is to have a LLM system be at the the stage in the
UX as linters and static code checkers. This would require LLMs to be much more
dependable and not like a junior dev. Example: Pylint is great at telling me
where and how my Python code violates its rules. Sometimes it even suggests a
fix. Pylint was built by humans, agreeing on these rules. Now imaging a
LLM-based refactoring assistant that could suggest improvements towards
clean-code and higher performance and is tied to certain rules. In this case I
want to avoid halucinations. As a developer I don’t need another source of
uncertain suggestions, my brain is likely providing enough of those.</p>
<p>The longer I think about it, the more I think the hopes, visions and goals we
base on the current capabilities of LLMs don’t stand on robust ground. LLMs
have capabilities and we don’t understand their extent. We don’t know their
failure modes and where we can trust them. For all that more research is
required. This can take the form of companies integrating them and failing and
of academics methodically figuring them out. But as a business that has no
expertise and willingness to dive deep into LLMs, I would not go that route and
rather build/use proven, boring software.</p>
]]></content>
        </item>
        
        <item>
            <title>Writing Julia Code Examples for Taleb&#39;s &#39;Statistical Consequences of Fat Tails&#39;</title>
            <link>https://david.wilde-ventures.com/posts/writing-julia-code-examples-scft/</link>
            <pubDate>Tue, 10 Aug 2021 20:15:20 +0200</pubDate>
            
            <guid>https://david.wilde-ventures.com/posts/writing-julia-code-examples-scft/</guid>
            <description>Inspired Tinkering I attended the Real World Risk Institute Seminar (iteration 15) earlier in 2021 and simultaneously started visiting the global reading club meetup of Nassim Nicholas Taleb&amp;rsquo;s first book of the technical Incerto series: &amp;ldquo;Statistical Consequences of Fat Tails&amp;rdquo;.
Among other things both events inspired me to &amp;ldquo;code-up&amp;rdquo; statistical examples, using the Julia language.
The first example can be seen here, and code can be checked-out here.
My current plan&amp;ndash;undoubtedly changing in the future&amp;ndash;is to add these examples to this repository</description>
            <content type="html"><![CDATA[<h2 id="inspired-tinkering">Inspired Tinkering</h2>
<p>I attended the <a href="https://realworldrisk.com"><em>Real World Risk Institute</em> Seminar</a> (iteration 15) earlier in 2021 and simultaneously started visiting the <a href="https://www.meetup.com/de-DE/global-technical-incerto-reading-club/">global reading club meetup</a> of Nassim Nicholas Taleb&rsquo;s first book of the technical Incerto series: <a href="https://arxiv.org/abs/2001.10488">&ldquo;Statistical Consequences of Fat Tails&rdquo;</a>.</p>
<p>Among other things both events inspired me to &ldquo;code-up&rdquo; statistical examples, using the <a href="https://arxiv.org/abs/2001.10488">Julia language</a>.</p>
<p>The first example can be seen <a href="https://david.wilde-ventures.com/SCFT/chapter04_01.html">here</a>,
and code can be checked-out <a href="https://github.com/davidchris/RWRI15Tinkering.jl/blob/main/src/SCFT-examples/chapter_04.jl">here</a>.</p>
<p>My current plan&ndash;undoubtedly changing in the future&ndash;is to add these examples to this <a href="https://github.com/davidchris/RWRI15Tinkering.jl">repository</a></p>
<h2 id="why">Why?</h2>
<p>As to the reason why I&rsquo;m doing this: practice&ndash;practice in the Julia language and practice of mathematical and statistical understanding&ndash;then, I will see what to make of this next.</p>
]]></content>
        </item>
        
        <item>
            <title>Creating This Website</title>
            <link>https://david.wilde-ventures.com/posts/creating-this-website/</link>
            <pubDate>Mon, 25 May 2020 09:10:55 +0000</pubDate>
            
            <guid>https://david.wilde-ventures.com/posts/creating-this-website/</guid>
            <description>This is the start of my personal website. And instead of writing some generic, somewhat empty first post saying &amp;lsquo;Hello World!&amp;rsquo;. I instead want to write about how I created this website. Foremost as a tutorial for myself.
Static Site Generation I went with Hugo, after some research online:
You could all build it by yourself Jekyll, generates html with themes from markdown, runs locally, well integrated with GitHub, written in Ruby (I think) Hugo, fast, works everywhere, easy to use, written in Go And yes, it&amp;rsquo;s fast and easy to use.</description>
            <content type="html"><![CDATA[<p>This is the start of my personal website. And instead of writing some generic, somewhat empty first post saying &lsquo;Hello World!&rsquo;. I instead want to write about how I created this website. Foremost as a tutorial for myself.</p>
<h2 id="static-site-generation">Static Site Generation</h2>
<p>I went with Hugo, after some research online:</p>
<ul>
<li>You could all build it by yourself</li>
<li>Jekyll, generates html with themes from markdown, runs locally, well integrated with GitHub, written in Ruby (I think)</li>
<li>Hugo, fast, works everywhere, easy to use, written in Go</li>
</ul>
<p>And yes, it&rsquo;s fast and easy to use. I rebuild my website from scratch several times one day and there was no hustle. Utilizing one of the many themes available (<a href="https://themes.gohugo.io">Hugo Themes</a>) is also straight forward.</p>
<p>For this site I used the <a href="https://themes.gohugo.io/themes/hugo-theme-hello-friend-ng/">hello-friend-ng theme</a> from <a href="https://atlialp.com">Djordje Atlialp</a>.</p>
<h2 id="domain">Domain</h2>
<p>I probably didn&rsquo;t do it properly here, let&rsquo;s see:</p>
<p>I bought or rented a domain, actually for another project, with GoDaddy. It seemed straight forward for me. Then, for some reason, I decided to create a dynamic domain name server (DDNS) not with GoDaddy, but with dnyu.com.</p>
<p>Though I forgot why I did that, it turns out that this was the easier choice for me. Managing my DNS from dnyu is more convenient. The UI looks older, but reacts faster and everything is more easily accessible.</p>
<h2 id="hosting">Hosting</h2>
<p>It was a rough ride here.</p>
<p>First I could not decide for several days whether to host it at home, on a VM in the cloud or via GitHub/Gitlab. I figured that I want it somewhat in my own hands while not doing everything by myself.</p>
<p>For now I went with hosting over GitHub pages. After testing GitLab pages and not wanting to go through setting up a VM myself for now it seemed like the best choice.</p>
<p><strong>Edit 2021-08-09</strong>: Today I set the page to enforce https&ndash;even though it is just a static page, some browser (will) expect https to be there.
This broke my page: theme was not working, and links were broken (i.e. adding the url twice behind each other).
A fix I found here: <a href="https://github.com/matcornic/hugo-theme-learn/issues/204">Theme on github pages not working</a>.</p>
<ul>
<li>I changed the <code>baseURL</code> to include the https</li>
<li>remove the contents of the <code>public</code> folder</li>
<li>rebuild the site</li>
</ul>
<p>Now it seems to be fixed.</p>
<h2 id="publishing">Publishing</h2>
<p>Publishing goes as easy as described here: <a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">Deploy Hugo as a GitHub Pages project</a>.</p>
<p><strong>Edit 2021-08-09</strong>: Something I forgot to add here which confused me a lot in the last few days is to have my <code>public/</code> directory as a git sub-module.
This sub-module has the GitHub Page as its remote.
The &lsquo;rest&rsquo; of the code, the repository, is the source to generate the page, which goes into another git repository.</p>
<p>Thanks to: <a href="https://www.mytechramblings.com/posts/create-a-website-with-hugo-and-gh/">Create and host a blog with Hugo and GitHub Pages in less than 30 minutes</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
